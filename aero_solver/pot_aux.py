import math
import scipy
import scipy.integrate as inte

'''
_N is used to denote an array of N size of a given structure, eg. Gamma_N is an array containing the vorticity strengths of N vortex blobs
'''

def trans_x2xi(x,t, U_ref):

    return x + t * U_ref

def trans_xi2x(xi,t,U_ref):

    return xi - t * U_ref

def trans_y2eta(y,t):

    amp = 1
    p = 0.5
    
    return y - amp*math.cos(p*t)

def trans_eta2y(eta, t):

    amp = 1
    p = 0.5 

    return eta + amp*math.cos(p*t)


def h_dot():
    amp = 1
    p = 2
    return lambda t: p * amp * math.sin(p*t)

def eta(xi):

    return 0.0

def u_ind(Gamma_n, eta_n, xi_n, v_core, c):
    '''
    -induced velocity in the x direction due to vortex blob k
    '''

    trans = lambda theta: 0.5 * c * (1 - math.cos(theta))

    return lambda theta: 0.5 * Gamma_n / math.pi * (eta(trans(theta)) - eta_n) / math.sqrt(((trans(theta)- xi_n)**2 + (eta(trans) - eta_n)**2)**2 + v_core**4)

def v_ind(Gamma_n, eta_n, xi_n, v_core, c):
    '''
    -induced velocity in the y direction due to vortex blob k
    '''

    trans = lambda theta: 0.5 * c * (1 - math.cos(theta))

    return lambda theta: 0.5 * Gamma_n / math.pi * (trans(theta) - xi_n) / math.sqrt(((trans(theta) - xi_n)**2 + (eta(trans(theta))- eta_n)**2)**2 + v_core**4)

def V_ind_b(gamma, xi_n, eta_n, c, eta_xi):
    '''
    - takes in vorticity distribution gamma
    - find the induced velocity of the vorticity distribution at point (xi_n, eta_n)
    '''

    integrand_u = lambda xi: gamma(xi) * (eta_n - eta_xi(xi)) / ((xi_n - xi)**2 + (eta_n - eta_xi(xi))**2)

    def_int_u, extra = inte.quad(integrand_u, 0, c)

    u_ind = 0.5 / math.pi * def_int_u

    integrand_v = lambda xi: gamma(xi) * (xi_n - xi) / ((xi_n - xi)**2 + (eta_n - eta_xi(xi))**2)

    def_int_v, extra = inte.quad(integrand_v, 0, c)

    v_ind = 0.5 / math.pi * def_int_v 

    return u_ind, v_ind

def V_ind_ub(xi, eta, xi_n, eta_n, gamma, v_core):

    '''
    - calculates the induced velocity at a point by another vortex blob
    '''

    u_ind_ub = 0.5 * gamma / math.pi * (eta - eta_n) / math.sqrt(((xi - xi_n)**2 + (eta - eta_n)**2)**2 + v_core**4)

    v_ind_ub = 0.5 * gamma / math.pi * (xi - xi_n) / math.sqrt(((xi - xi_n)**2 + (eta - eta_n)**2)**2 + v_core**4)

    return u_ind_ub, v_ind_ub

def dndeta(Gamma_n, eta_n, xi_n, v_core, alpha_eff, c):
    '''
    - velocity field generated by vortex blob k
    - returns dndeta(eta, xi)
    '''

    u = u_ind(Gamma_n, eta_n, xi_n, v_core, c)
    v = v_ind(Gamma_n, eta_n, xi_n, v_core, c)

    return lambda theta: u(theta) * math.sin(alpha_eff) + v(theta) * math.cos(alpha_eff)

def W_0(alpha_eff, U_ref):
    '''
    - downwash function from free stream
    - return W_0(theta, t)
    '''

    y_dot = h_dot()
    # y_dot = lambda t: 0.0*t

    return lambda theta, t: - U_ref * math.sin(alpha_eff) + y_dot(t) * math.cos(alpha_eff)


def W_theta(W_xi, c):
    '''
    - downwash function after applying glauert transformation
    '''

    trans = lambda_xi_2_theta(c)

    return lambda theta, eta, t: W_xi(trans(theta), eta, t)



def Gamma_b(A_0, A_1, U_ref, c):
    '''
    - calculates the circulation of the vortex distribution on the camber line
    '''

    return math.pi * c * U_ref * (A_0 + A_1 * 0.5)

def xi_2_theta(xi,c):
    '''
    - glauert's transformation from body fixed frame
    '''

    return math.acos(1 - 2*xi / c)

def theta_2_xi(theta,c):
    '''
    - inverse of glauert's transformation
    '''

    return 0.5 * c * (1 - math.cos(theta))

def lambda_xi_2_theta(c):
    '''
    - glauert's transformation from body fixed frame
    '''

    return lambda xi: math.acos(1 - 2*xi / c)

def lambda_theta_2_xi(c):
    '''
    - inverse of glauert's transformation
    '''

    return lambda theta: 0.5 * c * (1 - math.cos(theta))

