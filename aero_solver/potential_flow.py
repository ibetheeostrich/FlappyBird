import math
import scipy
import scipy.integrate

'''
_N is used to denote an array of N size of a given structure, eg. Gamma_N is an array containing the vorticity strengths of N vortex blobs
'''

def u_ind(Gamma_n, eta, xi, eta_n, xi_n, v_core):
    '''
    -induced velocity in the x direction due to vortex blob k
    '''
    return lambda xi, eta: 0.5 * Gamma_n / math.pi() * (eta - eta_n) / math.sqrt(((xi - xi_n)**2 + (eta - eta_n)**2)**2 + v_core**4)

def v_ind(Gamma_n, eta, xi, eta_n, xi_n, v_core):
    '''
    -induced velocity in the y direction due to vortex blob k
    '''
    return lambda xi, eta: 0.5 * Gamma_n / math.pi() * (xi - xi_n) / math.sqrt(((xi - xi_n)**2 + (eta - eta_n)**2)**2 + v_core**4)

def dndeta(Gamma_n, eta, xi, eta_n, xi_n, v_core, alpha_eff):
    '''
    - velocity field generated by vortex blob k
    '''

    return lambda eta, xi: u_ind(Gamma_n, eta, xi, eta_n, xi_n, v_core) * math.sin(alpha_eff) + v_ind(Gamma_n, eta, xi, eta_n, xi_n, v_core) * math.cos(alpha_eff)

def W_xi(Gamma_N, eta, xi, eta_N, xi_N, v_core, alpha_eff, N, U_ref):
    '''
    - downwash function
    '''

    W_n = lambda xi, eta, t: - U_ref * math.sin(alpha_eff) + (eta - h_dot)

    Gamma_n = 0
    eta_n   = 0
    xi_n    = 0

    for n in  range(N):

        Gamma_n = Gamma_N[n]
        eta_n   = eta_N[n]
        xi_n    = xi_N[n]

        W_n = lambda xi, eta, t: W_n + dndeta(Gamma_n, eta, xi, eta_n, xi_n, v_core, alpha_eff)

    return W_n

def W_theta(W_xi, xi_2_theta, c):
    '''
    - downwash function after applying glauert transformation
    '''
    return lambda theta, eta, t: W_xi(xi_2_theta(c), eta, t)

def A_0(func,llim,ulim, eta, t):
    '''
    - first fourier coefficient for vorticity distribution at a given time step
    '''
    return 2 / math.pi * scipy.integrate.quad(func, llim, ulim, args=(eta, t))

def A_n(func,llim,ulim, eta, t, n):
    '''
    - first fourier coefficient for vorticity distribution at a given time step
    '''

    integrand = lambda theta, eta, t: func(theta, eta, t) * math.cos(n*theta)

    return - 1 / math.pi * scipy.integrate.quad(func, llim, ulim, args=(eta, t))

def Gamma_b(A_0, A_1, U_ref, c):
    '''
    - calculates the circulation of the vortex distribution on the camber line
    '''

    return math.pi * c * U_ref * (A_0 + A_1 * 0.5)

def h_dot(t):
    amp = 1
    p = 1
    return lambda eta, t: eta + amp*math.sin(p*t)

def xi_2_theta(xi,c):
    '''
    - glauert's transformation from body fixed frame
    '''

    return math.acos(1 - 2*xi / c)

def theta_2_xi(theta,c):
    '''
    - inverse of glauert's transformation
    '''

    return 0.5 * c * (1 - math.cos(theta))

def lambda_xi_2_theta(c):
    '''
    - glauert's transformation from body fixed frame
    '''

    return lambda xi: math.acos(1 - 2*xi / c)

def lambda_theta_2_xi(c):
    '''
    - inverse of glauert's transformation
    '''

    return lambda theta: 0.5 * c * (1 - math.cos(theta))

